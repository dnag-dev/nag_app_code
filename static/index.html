<!DOCTYPE html>
<!-- Nag Digital Twin v1.4.0 - ChatGPT Style Voice Assistant -->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nag - The Digital Twin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {margin:0;font-family:'Segoe UI',sans-serif;background:linear-gradient(to bottom right,#000,#1a1a1a);color:#fff;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;overflow:hidden;}
    h1{font-size:2rem;margin-bottom:0.2rem;}
    p{margin-top:0;font-style:italic;opacity:0.8;}
    #orb{width:120px;height:120px;border-radius:50%;margin:2rem auto;background:radial-gradient(circle,#00f2ff,#001f3f);box-shadow:0 0 25px rgba(0,255,255,0.6);transition:all 0.4s ease-in-out;animation:pulseIdle 2s infinite;position:relative;cursor:pointer;}
    #orb.listening{background:radial-gradient(circle,#ff7300,#a62c00);animation:pulseListening 1s infinite;}
    #orb.speaking{background:radial-gradient(circle,#00ff8c,#004d33);animation:pulseSpeaking 1s infinite;}
    #orb.thinking{background:radial-gradient(circle,#ffcc00,#cc7700);animation:pulseThinking 1.5s infinite;}
    @keyframes pulseIdle{0%,100%{transform:scale(1);box-shadow:0 0 20px rgba(0,255,255,0.2);}50%{transform:scale(1.05);box-shadow:0 0 30px rgba(0,255,255,0.4);}}
    @keyframes pulseListening{0%,100%{transform:scale(1);box-shadow:0 0 30px rgba(255,115,0,0.3);}50%{transform:scale(1.1);box-shadow:0 0 40px rgba(255,115,0,0.5);}}
    @keyframes pulseSpeaking{0%,100%{transform:scale(1);box-shadow:0 0 30px rgba(0,255,140,0.4);}50%{transform:scale(1.1);box-shadow:0 0 40px rgba(0,255,140,0.6);}}
    @keyframes pulseThinking{0%,100%{transform:scale(1);box-shadow:0 0 30px rgba(255,204,0,0.3);}50%{transform:scale(1.08);box-shadow:0 0 40px rgba(255,204,0,0.5);}}
    #debug{width:90%;max-height:180px;overflow-y:auto;background:#111;border:1px solid #333;padding:10px;font-family:monospace;font-size:0.85rem;color:#0f0;margin-top:1rem;}
    #controls{display:flex;flex-direction:row;align-items:center;justify-content:center;margin-top:1rem;gap:10px;}
    .btn{padding:10px 20px;font-size:1rem;border:none;background-color:#00f2ff;color:#000;border-radius:10px;cursor:pointer;}
    .btn:disabled{background-color:#555;cursor:not-allowed;}
    .play-button{padding:8px 16px;margin:10px auto;display:block;background-color:#00ff8c;color:#000;border:none;border-radius:8px;cursor:pointer;font-weight:bold;}
    .version{position:fixed;bottom:5px;right:10px;font-size:10px;opacity:0.4;}
    #volume-indicator{position:absolute;width:100%;height:100%;border-radius:50%;top:0;left:0;overflow:hidden;pointer-events:none;}
    .volume-bar{position:absolute;bottom:0;left:0;width:100%;background-color:rgba(255,255,255,0.3);transition:height 0.1s ease;}
    .walkie-talkie-hint{margin-top:5px;font-size:0.8rem;opacity:0.7;text-align:center;}
    #mode-toggle{background:none;border:none;color:#00f2ff;text-decoration:underline;cursor:pointer;font-size:0.8rem;padding:5px;margin-top:0;opacity:0.7;}
    #pause-btn{background-color:#ff4f4f;}
    #pause-btn.paused{background-color:#4fff4f;}
  </style>
</head>
<body>
  <h1>Welcome to Nag</h1>
  <p>The digital extension of Dinakara's mind ‚Äî therapist, companion, unfiltered mirror.</p>
  <div id="orb" class="idle">
    <div id="volume-indicator">
      <div class="volume-bar" style="height: 0"></div>
    </div>
  </div>
  <audio id="audio" hidden></audio>
  
  <div id="controls">
    <button id="toggle-btn" class="btn">Start Conversation</button>
    <button id="pause-btn" class="btn" disabled>Pause</button>
  </div>
  
  <div class="walkie-talkie-hint" id="mode-hint">Click &amp; hold the orb to use walkie-talkie mode</div>
  <button id="mode-toggle">Switch to continuous mode</button>
  
  <div id="debug"><strong>Debug Log:</strong></div>
  <div class="version">v1.4.0</div>

  <script>
    console.log("Nag Digital Twin v1.4.0 loaded - ChatGPT Style Voice Assistant");
    
    const orb = document.getElementById("orb");
    const audio = document.getElementById("audio");
    const debugBox = document.getElementById("debug");
    const toggleBtn = document.getElementById("toggle-btn");
    const pauseBtn = document.getElementById("pause-btn");
    const volumeBar = document.querySelector(".volume-bar");
    const modeToggle = document.getElementById("mode-toggle");
    const modeHint = document.getElementById("mode-hint");

    let mediaRecorder;
    let audioChunks = [];
    let stream;
    let listening = false;
    let interrupted = false;
    let currentPlayButton = null;
    let emptyTranscriptionCount = 0;
    let isUploading = false;
    let isPaused = false;
    let isWalkieTalkieMode = true;
    let analyserNode = null;
    let walkieTalkieActive = false;
    let silenceTimer = null;
    let longRecordingTimer = null;
    
    // Detect browser environment
    const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    
    // Flag to track if audio has been unlocked
    let audioUnlocked = false;

    function unlockAudio() {
      if (audioUnlocked) return Promise.resolve(true);
      
      return new Promise((resolve) => {
        const silentAudio = new Audio("data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAADQgD///////////////////////////////////////////8AAAA8TEFNRTMuMTAwAQAAAAAAAAAAABSAJAJAQgAAgAAAA0L2YLwAAAAAAAAAAAAAAAAAAAAA//sQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//sQZB4P8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAEVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=");
        silentAudio.play().then(() => {
          audioUnlocked = true;
          logDebug("üîä Audio unlocked successfully");
          resolve(true);
        }).catch(e => {
          logDebug("‚ö†Ô∏è Could not unlock audio automatically: " + e.message);
          resolve(false);
        });
      });
    }

    function removePlayButton() {
      if (currentPlayButton) {
        currentPlayButton.remove();
        currentPlayButton = null;
      }
    }

    if (!window.MediaRecorder) {
      logDebug("‚ö†Ô∏è Your browser doesn't support MediaRecorder API!");
      toggleBtn.disabled = true;
      toggleBtn.textContent = "Not supported in this browser";
    }

    function logDebug(msg) {
      const p = document.createElement("p");
      p.textContent = msg;
      debugBox.appendChild(p);
      debugBox.scrollTop = debugBox.scrollHeight;
    }

    function setupVolumeVisualization(stream) {
      try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyserNode = audioContext.createAnalyser();
        const microphone = audioContext.createMediaStreamSource(stream);
        
        analyserNode.fftSize = 256;
        analyserNode.smoothingTimeConstant = 0.8;
        microphone.connect(analyserNode);
        
        const bufferLength = analyserNode.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        
        function updateVolume() {
          if (!analyserNode || !listening) return;
          
          analyserNode.getByteFrequencyData(dataArray);
          
          let sum = 0;
          for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i];
          }
          
          const average = sum / bufferLength;
          const volume = Math.min(100, Math.max(0, average * 2.5));
          
          volumeBar.style.height = `${volume}%`;
          
          if (isWalkieTalkieMode && !walkieTalkieActive) {
            requestAnimationFrame(updateVolume);
            return;
          }
          
          if (!isWalkieTalkieMode && volume < 5) {
            if (!silenceTimer) {
              silenceTimer = setTimeout(() => {
                if (mediaRecorder && mediaRecorder.state === "recording") {
                  logDebug("üîá Silence detected, stopping recording");
                  stopRecording();
                }
                silenceTimer = null;
              }, 1500);
            }
          } else {
            if (silenceTimer) {
              clearTimeout(silenceTimer);
              silenceTimer = null;
            }
          }
          
          requestAnimationFrame(updateVolume);
        }
        
        requestAnimationFrame(updateVolume);
      } catch (e) {
        logDebug("‚ö†Ô∏è Volume visualization not available: " + e.message);
      }
    }

    async function startListening() {
      if (isUploading || isPaused) return;
      
      try {
        removePlayButton();
        emptyTranscriptionCount = 0;
        
        orb.classList.remove("idle", "speaking", "thinking");
        orb.classList.add("listening");
        logDebug("üéôÔ∏è Listening... (v1.4.0 - " + (isWalkieTalkieMode ? "walkie-talkie mode" : "continuous mode") + ")");

        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        setupVolumeVisualization(stream);

        let mimeType = "";
        const supportedTypes = (isiOS || isSafari) 
          ? ["audio/mp4", "audio/mpeg", "audio/webm", "audio/ogg;codecs=opus", ""]
          : ["audio/webm", "audio/mp4", "audio/mpeg", "audio/ogg;codecs=opus", ""];
        
        for (const type of supportedTypes) {
          if (MediaRecorder.isTypeSupported(type)) {
            mimeType = type;
            logDebug(`Using audio format: ${mimeType || "browser default"}`);
            break;
          }
        }
        
        mediaRecorder = new MediaRecorder(stream, mimeType ? { mimeType } : {});
        audioChunks = [];

        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);

        mediaRecorder.onstop = async () => {
          if (interrupted) return;
          orb.classList.remove("listening");
          
          if (longRecordingTimer) {
            clearTimeout(longRecordingTimer);
            longRecordingTimer = null;
          }
          
          if (silenceTimer) {
            clearTimeout(silenceTimer);
            silenceTimer = null;
          }
          
          if (audioChunks.length === 0) {
            logDebug("‚ö†Ô∏è No audio recorded. Please try again.");
            orb.classList.add("idle");
            if (!isWalkieTalkieMode && !isPaused) {
              setTimeout(() => {
                if (!interrupted && !isPaused) startListening();
              }, 1000);
            }
            return;
          }
          
          const blob = new Blob(audioChunks, mimeType ? { type: mimeType } : {});
          const formData = new FormData();
          
          let fileExt = "audio";
          if (mimeType.includes("webm")) fileExt = "webm";
          else if (mimeType.includes("mp4") || mimeType.includes("mpeg")) fileExt = "mp3";
          else if (mimeType.includes("ogg")) fileExt = "ogg";
          
          formData.append("file", blob, `input.${fileExt}`);

          try {
            isUploading = true;
            logDebug("üì§ Uploading voice...");
            
            const res = await fetch("/transcribe", { 
              method: "POST", 
              body: formData 
            });
            
            isUploading = false;

            let data;
            try {
              const rawText = await res.text();
              try {
                data = JSON.parse(rawText);
              } catch (jsonErr) {
                logDebug("‚ùå JSON parse failed: " + jsonErr.message);
                logDebug("Raw response: " + rawText.substring(0, 100) + "...");
                orb.classList.add("idle");
                if (!isWalkieTalkieMode && !isPaused) {
                  setTimeout(() => {
                    if (!interrupted && !isPaused) startListening();
                  }, 1000);
                }
                return;
              }
            } catch (textErr) {
              logDebug("‚ùå Failed to read response: " + textErr.message);
              orb.classList.add("idle");
              if (!isWalkieTalkieMode && !isPaused) {
                setTimeout(() => {
                  if (!interrupted && !isPaused) startListening();
                }, 1000);
              }
              return;
            }

            const message = (data.transcription || "").trim();
            logDebug("üìù Transcribed: " + (message || "No speech detected"));

            const wordCount = message.split(/\s+/).filter(Boolean).length;
            if (!message || message === "undefined" || wordCount <= 1) {
              logDebug("‚ö†Ô∏è Too short or empty message. Continuing to listen...");
              emptyTranscriptionCount++;
              
              if (emptyTranscriptionCount >= 3) {
                emptyTranscriptionCount = 0;
                await sendToChat("I didn't hear enough. Please try speaking a complete sentence.");
              } else {
                orb.classList.add("idle");
                if (!isWalkieTalkieMode && !isPaused) {
                  setTimeout(() => {
                    if (!interrupted && !isPaused) startListening();
                  }, 1000);
                }
              }
              return;
            }

            emptyTranscriptionCount = 0;
            await sendToChat(message);
          } catch (e) {
            isUploading = false;
            logDebug("‚ùå Transcription error: " + e.message);
            orb.classList.add("idle");
            if (!isWalkieTalkieMode && !isPaused) {
              setTimeout(() => {
                if (!interrupted && !isPaused) startListening();
              }, 1000);
            }
          }
        };

        if (!isWalkieTalkieMode) {
          startRecording();
        }
        
        pauseBtn.disabled = false;
      } catch (e) {
        logDebug("üö´ Mic access failed: " + e.message);
        orb.classList.remove("listening");
        orb.classList.add("idle");
      }
    }
    
    function startRecording() {
      if (!mediaRecorder || mediaRecorder.state === "recording") return;
      
      audioChunks = [];
      mediaRecorder.start();
      
      longRecordingTimer = setTimeout(() => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          logDebug("‚è±Ô∏è Maximum recording time reached");
          stopRecording();
        }
      }, 15000);
    }
    
    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
    }

    async function stopListening() {
      interrupted = true;
      
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
      }
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
      
      if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
      }
      
      if (analyserNode) {
        analyserNode = null;
      }
      
      volumeBar.style.height = "0%";
      removePlayButton();
      pauseBtn.disabled = true;
    }

    async function sendToChat(message) {
      if (isUploading || isPaused) {
        logDebug("‚è≥ Still processing or paused, please wait...");
        return;
      }
      
      removePlayButton();
      orb.classList.remove("listening", "idle", "speaking");
      orb.classList.add("thinking");
      logDebug("üí¨ Sending to Nag...");

      try {
        isUploading = true;
        const res = await fetch("/chat", {
          method: "POST",
          headers: { 
              "Content-Type": "application/json; charset=utf-8",
              "Accept": "application/json"
          },
          body: JSON.stringify({ message })
        });
        isUploading = false;

        if (!res.ok) {
          throw new Error(`Server error: ${res.status} ${res.statusText}`);
        }

        const rawText = await res.text();
        
        let data;
        try {
            data = JSON.parse(rawText);
        } catch (jsonErr) {
            logDebug("‚ùå Chat response JSON parse failed: " + jsonErr.message);
            logDebug("Raw response: " + rawText.substring(0, 150) + "...");
            orb.classList.remove("thinking");
            orb.classList.add("idle");
            if (!isWalkieTalkieMode && !isPaused) {
              setTimeout(() => {
                if (!interrupted && !isPaused) startListening();
              }, 1000);
            }
            return;
        }

        logDebug("üß† Nag: " + data.response);
        orb.classList.remove("thinking");

        if (data.audio_url) {
          orb.classList.add("speaking");
          
          try {
            await new Promise((resolve) => {
              const onready = () => {
                audio.oncanplaythrough = null;
                audio.onerror = null;
                resolve();
              };
              audio.oncanplaythrough = onready;
              audio.onerror = onready;
              audio.src = data.audio_url;
              audio.load();
            });
          } catch (e) {
            logDebug("‚ö†Ô∏è Audio preload warning: " + e.message);
          }
          
          await unlockAudio();
          
          try {
            let playResult = audio.play();
            
            audio.onended = () => {
              orb.classList.remove("speaking");
              orb.classList.add("idle");
              if (!isWalkieTalkieMode && !isPaused && !interrupted) {
                startListening();
              }
            };
            
            if (playResult !== undefined) {
              playResult.catch(e => {
                logDebug("üîá Audio play failed: " + e.message);
                showPlayButton(data.audio_url);
              });
            }
          } catch (e) {
            logDebug("üîá Audio play exception: " + e.message);
            showPlayButton(data.audio_url);
          }
        } else {
          logDebug("‚ö†Ô∏è No audio returned.");
          orb.classList.add("idle");
          if (!isWalkieTalkieMode && !isPaused) {
            setTimeout(() => {
              if (!interrupted && !isPaused) startListening();
            }, 1000);
          }
        }
      } catch (e) {
        isUploading = false;
        logDebug("‚ùå Chat error: " + e.message);
        orb.classList.remove("thinking");
        orb.classList.add("idle");
        if (!isWalkieTalkieMode && !isPaused) {
          setTimeout(() => {
            if (!interrupted && !isPaused) startListening();
          }, 1000);
        }
      }
    }
    
    function showPlayButton(audioUrl) {
      orb.classList.remove("speaking", "thinking");
      orb.classList.add("idle");
      
      removePlayButton();
      
      let playButton = document.createElement("button");
      playButton.innerText = "‚ñ∂Ô∏è Play Response";
      playButton.className = "play-button";
      currentPlayButton = playButton;
      
      document.body.insertBefore(playButton, debugBox);
      setTimeout(() => playButton.focus(), 100);
      
      playButton.onclick = () => {
        audioUnlocked = true;
        
        orb.classList.remove("idle");
        orb.classList.add("speaking");
        
        audio.src = audioUrl;
        audio.load();
        
        audio.play()
          .then(() => {
            removePlayButton();
          })
          .catch(err => {
            logDebug("üîá Manual play failed: " + err.message);
            orb.classList.remove("speaking");
            orb.classList.add("idle");
          });
        
        audio.onended = () => {
          orb.classList.remove("speaking");
          orb.classList.add("idle");
          if (!isWalkieTalkieMode && !isPaused && !interrupted) {
            startListening();
          }
        };
      };
    }

    function setupWalkieTalkieMode() {
      orb.addEventListener("mousedown", function(e) {
        if (!isWalkieTalkieMode || !listening || isUploading || isPaused) return;
        
        walkieTalkieActive = true;
        logDebug("üîä Walkie-talkie active - speak now");
        orb.classList.add("listening");
        
        if (mediaRecorder && mediaRecorder.state !== "recording") {
          startRecording();
        }
      });
      
      orb.addEventListener("touchstart", function(e) {
        if (!isWalkieTalkieMode || !listening || isUploading || isPaused) return;
        e.preventDefault();
        
        walkieTalkieActive = true;
        logDebug("üîä Walkie-talkie active - speak now");
        orb.classList.add("listening");
        
        if (mediaRecorder && mediaRecorder.state !== "recording") {
          startRecording();
        }
      });
      
      const endWalkieTalkie = function() {
        if (!walkieTalkieActive) return;
        
        walkieTalkieActive = false;
        logDebug("üîä Walkie-talkie released");
        
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        }
      };
      
      orb.addEventListener("mouseup", endWalkieTalkie);
      orb.addEventListener("mouseleave", endWalkieTalkie);
      orb.addEventListener("touchend", function(e) {
        e.preventDefault();
        endWalkieTalkie();
      });
      orb.addEventListener("touchcancel", function(e) {
        e.preventDefault();
        endWalkieTalkie();
      });
    }

    function setupInterruptionHandling() {
      document.addEventListener('click', function(e) {
        if (e.target === toggleBtn || 
            e.target === pauseBtn ||
            e.target === modeToggle ||
            e.target === orb ||
            (currentPlayButton && (e.target === currentPlayButton || currentPlayButton.contains(e.target)))) {
          return;
        }
        
        if (orb.classList.contains("speaking")) {
          logDebug("üîÑ Interrupting AI response...");
          audio.pause();
          audio.currentTime = 0;
          orb.classList.remove("speaking");
          orb.classList.add("idle");
          
          if (!isWalkieTalkieMode && !isPaused) {
            setTimeout(() => {
              if (!interrupted && !isPaused) startListening();
            }, 500);
          }
        }
      });
    }

    toggleBtn.addEventListener("click", async () => {
      await unlockAudio();
      
      if (listening) {
        logDebug("‚èπÔ∏è Stopping conversation...");
        toggleBtn.textContent = "Resume Conversation";
        await stopListening();
        orb.classList.remove("listening", "speaking", "thinking");
        orb.classList.add("idle");
        listening = false;
        walkieTalkieActive = false;
      } else {
        logDebug("‚ñ∂Ô∏è Starting conversation...");
        toggleBtn.textContent = "Stop Conversation";
        interrupted = false;
        isPaused = false;
        pauseBtn.textContent = "Pause";
        pauseBtn.classList.remove("paused");
        await startListening();
        listening = true;
      }
    });
    
    pauseBtn.addEventListener("click", function() {
      if (!listening) return;
      
      if (isPaused) {
        // Resume conversation
        isPaused = false;
        pauseBtn.textContent = "Pause";
        pauseBtn.classList.remove("paused");
        logDebug("‚ñ∂Ô∏è Conversation resumed");
        
        if (!isWalkieTalkieMode) {
          startListening();
        }
      } else {
        // Pause conversation
        isPaused = true;
        pauseBtn.textContent = "Resume";
        pauseBtn.classList.add("paused");
        logDebug("‚è∏Ô∏è Conversation paused");
        
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        }
      }
    });
    
    modeToggle.addEventListener("click", function() {
      isWalkieTalkieMode = !isWalkieTalkieMode;
      
      if (isWalkieTalkieMode) {
        modeToggle.textContent = "Switch to continuous mode";
        modeHint.textContent = "Click & hold the orb to use walkie-talkie mode";
        logDebug("üé§ Switched to walkie-talkie mode");
        
        if (mediaRecorder && mediaRecorder.state === "recording") {
          stopRecording();
        }
      } else {
        modeToggle.textContent = "Switch to walkie-talkie mode";
        modeHint.textContent = "Nag will listen continuously for your voice";
        logDebug("üé§ Switched to continuous mode");
        
        if (listening && !isPaused) {
          startListening();
        }
      }
    });
    
    setupWalkieTalkieMode();
    setupInterruptionHandling();
    
    // Log initial browser capabilities
    if (window.MediaRecorder) {
      logDebug("‚úÖ MediaRecorder is supported in this browser");
      logDebug(isiOS ? "üì± iOS device detected" : "üíª Desktop browser detected");
      logDebug(isSafari ? "üß≠ Safari browser detected" : "üåê Non-Safari browser detected");
      
      const supportedTypes = [
        "audio/webm", 
        "audio/mp4", 
        "audio/mpeg", 
        "audio/ogg;codecs=opus"
      ];
      for (const type of supportedTypes) {
        logDebug(`${type}: ${MediaRecorder.isTypeSupported(type) ? '‚úÖ' : '‚ùå'}`);
      }
    }
  </script>
</body>
</html>