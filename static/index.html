<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nag - The Digital Twin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to bottom right, #000000, #1a1a1a);
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      overflow: hidden;
    }
    h1 { font-size: 2rem; margin-bottom: 0.2rem; }
    p { margin-top: 0; font-style: italic; opacity: 0.8; }
    #orb {
      width: 120px; height: 120px; border-radius: 50%;
      margin: 2rem auto;
      background: radial-gradient(circle, #00f2ff, #001f3f);
      box-shadow: 0 0 25px rgba(0,255,255,0.6);
      transition: all 0.4s ease-in-out;
      animation: pulseIdle 2s infinite;
    }
    #orb.listening {
      background: radial-gradient(circle, #ff7300, #a62c00);
      animation: pulseListening 1s infinite;
    }
    #orb.speaking {
      background: radial-gradient(circle, #00ff8c, #004d33);
      animation: pulseSpeaking 1s infinite;
    }
    @keyframes pulseIdle {
      0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(0,255,255,0.2); }
      50% { transform: scale(1.05); box-shadow: 0 0 30px rgba(0,255,255,0.4); }
    }
    @keyframes pulseListening {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,115,0,0.3); }
      50% { transform: scale(1.1); box-shadow: 0 0 40px rgba(255,115,0,0.5); }
    }
    @keyframes pulseSpeaking {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(0,255,140,0.4); }
      50% { transform: scale(1.1); box-shadow: 0 0 40px rgba(0,255,140,0.6); }
    }
    #debug {
      width: 90%; max-height: 250px; overflow-y: auto;
      background: #111; border: 1px solid #333;
      padding: 10px; font-family: monospace;
      font-size: 0.85rem; color: #0f0; margin-top: 2rem;
    }
    #toggleButton {
      padding: 10px 20px;
      font-size: 1rem;
      margin-top: 1rem;
      border: none;
      background-color: #00f2ff;
      color: #000;
      border-radius: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Welcome to Nag</h1>
  <p>The digital extension of Dinakara‚Äôs mind ‚Äî therapist, companion, unfiltered mirror.</p>
  <div id="orb" class="idle"></div>
  <audio id="audio" hidden></audio>
  <button id="toggleButton">Start Conversation</button>
  <div id="debug"><strong>Debug Log:</strong></div>

  <script>
    const orb = document.getElementById("orb");
    const audio = document.getElementById("audio");
    const debugBox = document.getElementById("debug");
    const toggleButton = document.getElementById("toggleButton");

    let mediaRecorder, audioChunks = [], stream;
    let listening = false, interrupted = false;

    function logDebug(msg) {
      const p = document.createElement("p");
      p.textContent = msg;
      debugBox.appendChild(p);
      debugBox.scrollTop = debugBox.scrollHeight;
    }

    async function startListening() {
      try {
        orb.classList.remove("idle", "speaking");
        orb.classList.add("listening");
        logDebug("üéôÔ∏è Listening...");
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });
        audioChunks = [];

        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstop = async () => {
          if (interrupted) return;
          orb.classList.remove("listening");
          const blob = new Blob(audioChunks, { type: "audio/webm" });
          const formData = new FormData();
          formData.append("file", blob, "input.webm");

          try {
            logDebug("üì§ Uploading voice...");
            const res = await fetch("/transcribe", { method: "POST", body: formData });
            const data = await res.json();
            const message = (data.transcription || "").trim();
            logDebug("üìù Transcribed: " + message);
            if (!message) return logDebug("‚ö†Ô∏è Empty transcription. Skipping.");
            await sendToChat(message);
          } catch (e) {
            logDebug("‚ùå Transcription error: " + e.message);
          }
        };

        mediaRecorder.start();
        setTimeout(() => mediaRecorder?.state === "recording" && mediaRecorder.stop(), 4000);
      } catch (e) {
        logDebug("üö´ Microphone access error: " + e.message);
        orb.classList.remove("listening");
        orb.classList.add("idle");
      }
    }

    async function stopListening() {
      interrupted = true;
      if (mediaRecorder?.state !== "inactive") mediaRecorder.stop();
      stream?.getTracks().forEach(t => t.stop());
      if (!audio.paused) {
        audio.pause();
        audio.currentTime = 0;
      }
    }

    async function sendToChat(message) {
      try {
        orb.classList.add("thinking");
        logDebug("üí¨ Sending to Nag...");
        const res = await fetch("/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ message })
        });

        const data = await res.json();
        orb.classList.remove("thinking");
        logDebug("üß† Nag: " + data.response);
        if (!data.audio_url) return logDebug("‚ö†Ô∏è No audio returned.");

        orb.classList.add("speaking");
        audio.src = data.audio_url;
        audio.load();
        audio.play().catch(e => logDebug("üîá Playback failed: " + e.message));
        audio.onended = () => {
          orb.classList.remove("speaking");
          orb.classList.add("idle");
          if (!interrupted) startListening();
        };
      } catch (e) {
        logDebug("‚ùå Chat error: " + e.message);
        orb.classList.remove("thinking");
        orb.classList.add("idle");
      }
    }

    toggleButton.addEventListener("click", async () => {
      if (listening) {
        logDebug("‚èπÔ∏è Stopping conversation...");
        toggleButton.textContent = "Resume Conversation";
        await stopListening();
        orb.classList.remove("listening", "speaking");
        orb.classList.add("idle");
      } else {
        logDebug("‚ñ∂Ô∏è Starting conversation...");
        toggleButton.textContent = "Stop Conversation";
        interrupted = false;
        await startListening();
      }
      listening = !listening;
    });
  </script>
</body>
</html>
